---
layout: post 
title: 'C++|NOIP2018提高组Day1T2|货币系统|晓不得考啥子'
date: 2018-11-10
---
## 题目描述
在网友的国度中共有n种不同面额的货币，第 i 种货币的面额为a[i]。   
你可以假设每一种货币都有无穷多张。  
为了方便,我们把货币种数为n、面额数组为a[1..n]的货币系统记作(n,a)。  
在一个完善的货币系统中，每一个非负整数的金额x都应该可以被表示出。   
即对每一个非负整数x，都存在n个非负整数t[i]满足a[i]*t[i]的和为x。  
然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额x不能被该货币系统表示出。  
例如在货币系统 n=3，a=[2,5,9] 中,金额1,3就无法被表示出来。  
两个货币系统(n,a)和(m,b)是等价的，当且仅当对于任意非负整数x，  
它要 么均可以被两个货币系统表出，要么不能被其中任何一个表出。  
现在网友们打算简化一下货币系统。  
他们希望找到一个货币系统(m,b)，满足(m,b)与原来的货币系统(n,a)等价，且m尽可能的小。  
他们希望你来协助完成这个艰巨的任务：找到最小的m。  
## 输入格式：
输入文件的第一行包含一个整数T，表示数据的组数。  
接下来按照如下格式分别给出T组数据。  
每组数据的第一行包含一个正整数n。  
接下来一行包含n个由空格隔开的正整数a[i]。  
## 输出格式：
输出文件共有T行，对于每组数据，输出一行一个正整数，表示所有与(n,a)等价的货币系统(m,b)中最小的m。  
## 输入样例：
2   
4   
3 19 10 6   
5   
11 29 13 19 17   
## 输出样例：
2     
5    
## 样例说明
在第一组数据中，货币系统(2,[3,10])和给出的货币系统(n,a)等价，并可以验证不存在m<2的等价的货币系统，因此答案为2。   
在第二组数据中，可以验证不存在m<n的等价的货币系统，因此答案为5。  
## 菜鸡的咆哮
考试的用回溯判断每种面额可否被其他面额凑出来  
码了5min结果炸了  
竟然没想到可以用数组直接推....  
菜鸡本鸡是我没错了QAQ  
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int T,n;
int num[105];
int vis[25005];
int main(){
    //freopen("money.in","r",stdin);
    //freopen("money.out","w",stdout);
    cin>>T;
    while(T--){
        cin>>n;
        int maxn=0;
        memset(vis,0,sizeof(vis));
        for(int i=1;i<=n;i++){
            cin>>num[i];
            maxn=max(maxn,num[i]);
            vis[num[i]]=1;
        }
        for(int i=1;i<=n;i++){
        	for(int j=num[i];j<=maxn;j++){
            	if(vis[j-num[i]]!=0){
            		vis[j]=vis[j-num[i]]+1;
            	}
        	}	
        }
        int ans=n;
        for(int i=1;i<=n;i++){
        	if(vis[num[i]]>1){
        		ans--;
        	}
        }
        cout<<ans<<endl;
    }
    return 0;
}
```
